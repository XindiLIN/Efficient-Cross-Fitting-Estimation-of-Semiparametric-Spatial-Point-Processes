knitr::opts_chunk$set(echo = TRUE)
load("/Users/xindilin/Downloads/doi_10_15146_5xcp-0d46__v20190607/bci.tree/bci.tree1.rdata")
cappfr = bci.tree1[bci.tree1$sp=="cappfr",]
dim(cappfr)
ppcap = ppp(cappfr$gx,cappfr$gy,window =owin(c(0,1000),c(0,500)))
cappfr = cappfr[!duplicated(cappfr[,c("gx","gy")]),]
ppcap = ppp(cappfr$gx,cappfr$gy,window =owin(c(0,1000),c(0,500)))
library(spatstat)
ppcap = ppp(cappfr$gx,cappfr$gy,window =owin(c(0,1000),c(0,500)))
ppcap
bei.extra
citation('spatstat')
version()
Version()
citation
citation('mgcv')
citation('stat')
citation('stats')
citation('gratia')
citation('dpylr')
citation('dplyr')
library(spatstat)
sessionInfo()
packageVersion(spatstat)
packageVersion('spatstat')
library(gratia)
library(dplyr)
library(ggplot2)
library(mgcv)
library(stats)
sessionInfo()
packageVersion('stats')
knitr::opts_chunk$set(echo = TRUE)
source('real_data_funcs.R')
library("gratia") # package for getting the fitted value of gam
library("mgcv")
library("dplyr")
alpha = 400
theta = 0.3
var = 0.2
scale = 0.2
formula=NULL
eta = 0.09
simulate_process = function(lambda,clusters,var,scale){
if(clusters=="Poisson"){
pp = rpoispp(lambda)
}
else{
pp_LGCP = rLGCP("exponential",0,var=var, scale=scale,win=owin(xrange = lambda$xrange,yrange = lambda$yrange))
lambda_LGCP = as.im(attr(pp_LGCP, "Lambda"),dimyx=lambda$dim[1])*lambda*exp(-var/2)
pp = rpoispp(lambda_LGCP)
}
return(pp)
}
set.seed(4)
clusters = "LGCP"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
seed=1
iter=1
print_t = 1
pcfknown=FALSE
window_size = "large"
ind_or_dep = "dep"
is.small = FALSE
is.independent = FALSE
nuisance_type="poly"
method = "logi"
data = generate_simulate_covariate(is.small = is.small, is.independent = is.independent)
cov_target = data$cov_target
cov_nuisance = data$cov_nuisance
alpha = 400
theta = 0.3
var = 0.2
scale = 0.2
formula=NULL
eta = 0.09
simulate_process = function(lambda,clusters,var,scale){
if(clusters=="Poisson"){
pp = rpoispp(lambda)
}
else{
pp_LGCP = rLGCP("exponential",0,var=var, scale=scale,win=owin(xrange = lambda$xrange,yrange = lambda$yrange))
lambda_LGCP = as.im(attr(pp_LGCP, "Lambda"),dimyx=lambda$dim[1])*lambda*exp(-var/2)
pp = rpoispp(lambda_LGCP)
}
return(pp)
}
set.seed(4)
clusters = "LGCP"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
formula = as.formula('pp~cov_target+I(cov_nuisance^2)')
# generate process
pp = simulate_process(lambda,clusters,var,scale)
# intensity of parametric misspecified model
fitted_para = ppm(pp~cov_target+cov_nuisance,method=method)
intensity_para = predict(fitted_para)
# intensity of oracle model
fitted_oracle = ppm(formula,method=method)
intensity_oracle = predict(fitted_oracle)
# # intensity of semiparametric model (logi)
# trend_linear = as.formula(paste("~",paste(c("cov_target","cov_nuisance"),collapse="+")))
# trend = "~cov_target+s(cov_nuisance)"
# ppmfit = ppm(Q = pp,trend = trend_linear ,covariates = data, method="logi")
# glmdata = ppmfit$internal$glmdata
# gamfit = gam(as.formula(paste('.logi.Y',trend)),data = glmdata, family = binomial(), subset = .logi.ok, weights = .logi.w)
# ## make the matrix consisting of cov_target and cov_nuisance in the uniform grid
# new_data = data.frame("cov_target" = c(cov_target[[1]]),"cov_nuisance" = c(cov_nuisance[[1]]))
#
# intensity_semi = fitted_values(gamfit,data = new_data,scale="link")$.fitted
#
# intensity_semi = matrix(intensity_semi,nrow = 100, ncol = 100)
# intensity of semiparametric model (mpl)
trend = "~cov_target+s(cov_nuisance)"
ppmfit =  ppm(Q = pp,trend = as.formula(trend) ,covariates = data, use.gam = TRUE, method="mpl")
intensity_semi = predict(ppmfit)
my_colormap = plot(intensity_semi)
my_colormap
my_colormap(1)
my_colormap(100)
?im.plot
?plot.im
summary(my_colormap)
s = summary(my_colormap)
s$n
s$discrete
s$breaks
View(s)
?colourmap
colormap = plot(intensity_semi)
s = summary(colormap)
s$outputs
my_colormap = colourmap(col=s$outputs,range = c(-220,1010))
plot(intensity_semi,col=my_colormap)
set.seed(4)
clusters = "LGCP"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
formula = as.formula('pp~cov_target+I(cov_nuisance^2)')
# generate process
pp = simulate_process(lambda,clusters,var,scale)
# intensity of parametric misspecified model
fitted_para = ppm(pp~cov_target+cov_nuisance,method=method)
intensity_para = predict(fitted_para)
# intensity of oracle model
fitted_oracle = ppm(formula,method=method)
intensity_oracle = predict(fitted_oracle)
# # intensity of semiparametric model (logi)
# trend_linear = as.formula(paste("~",paste(c("cov_target","cov_nuisance"),collapse="+")))
# trend = "~cov_target+s(cov_nuisance)"
# ppmfit = ppm(Q = pp,trend = trend_linear ,covariates = data, method="logi")
# glmdata = ppmfit$internal$glmdata
# gamfit = gam(as.formula(paste('.logi.Y',trend)),data = glmdata, family = binomial(), subset = .logi.ok, weights = .logi.w)
# ## make the matrix consisting of cov_target and cov_nuisance in the uniform grid
# new_data = data.frame("cov_target" = c(cov_target[[1]]),"cov_nuisance" = c(cov_nuisance[[1]]))
#
# intensity_semi = fitted_values(gamfit,data = new_data,scale="link")$.fitted
#
# intensity_semi = matrix(intensity_semi,nrow = 100, ncol = 100)
# intensity of semiparametric model (mpl)
trend = "~cov_target+s(cov_nuisance)"
ppmfit =  ppm(Q = pp,trend = as.formula(trend) ,covariates = data, use.gam = TRUE, method="mpl")
intensity_semi = predict(ppmfit)
colormap = plot(intensity_semi)
s = summary(colormap)
my_colormap = colourmap(col=s$outputs,range = c(-240,1020))
plot(intensity_semi-lambda,col=my_colormap)
plot(intensity_oracle-lambda,col=my_colormap)
plot(intensity_oracle-lambda,col=my_colormap)
set.seed(1)
clusters = "Poisson"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
formula = as.formula('pp~cov_target+I(cov_nuisance^2)')
# generate process
pp = simulate_process(lambda,clusters,var,scale)
# intensity of parametric misspecified model
fitted_para = ppm(pp~cov_target+cov_nuisance,method=method)
intensity_para = predict(fitted_para)
# intensity of oracle model
fitted_oracle = ppm(formula,method=method)
intensity_oracle = predict(fitted_oracle)
# # intensity of semiparametric model (logi)
# trend_linear = as.formula(paste("~",paste(c("cov_target","cov_nuisance"),collapse="+")))
# trend = "~cov_target+s(cov_nuisance)"
# ppmfit = ppm(Q = pp,trend = trend_linear ,covariates = data, method="logi")
# glmdata = ppmfit$internal$glmdata
# gamfit = gam(as.formula(paste('.logi.Y',trend)),data = glmdata, family = binomial(), subset = .logi.ok, weights = .logi.w)
# ## make the matrix consisting of cov_target and cov_nuisance in the uniform grid
# new_data = data.frame("cov_target" = c(cov_target[[1]]),"cov_nuisance" = c(cov_nuisance[[1]]))
#
# intensity_semi = fitted_values(gamfit,data = new_data,scale="link")$.fitted
#
# intensity_semi = matrix(intensity_semi,nrow = 100, ncol = 100)
# intensity of semiparametric model (mpl)
trend = "~cov_target+s(cov_nuisance)"
ppmfit =  ppm(Q = pp,trend = as.formula(trend) ,covariates = data, use.gam = TRUE, method="mpl")
intensity_semi = predict(ppmfit)
plot(intensity_semi-lambda,col=my_colormap)
plot(intensity_para-lambda)
s = summary(colormap)
my_colormap = colourmap(col=s$outputs,range = c(-240,1050))
plot(intensity_semi-lambda,col=my_colormap)
s = summary(colormap)
my_colormap = colourmap(col=s$outputs,range = c(-250,1040))
plot(intensity_semi-lambda,col=my_colormap)
s = summary(colormap)
my_colormap = colourmap(col=s$outputs,range = c(-260,1040))
plot(intensity_semi-lambda,col=my_colormap)
plot(intensity_oracle-lambda,col=my_colormap)
plot(intensity_para-lambda)
plot(intensity_para-lambda,col=my_colormap)
set.seed(1)
clusters = "LGCP"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
formula = as.formula('pp~cov_target+I(cov_nuisance^2)')
# generate process
pp = simulate_process(lambda,clusters,var,scale)
# intensity of parametric misspecified model
fitted_para = ppm(pp~cov_target+cov_nuisance,method=method)
intensity_para = predict(fitted_para)
# intensity of oracle model
fitted_oracle = ppm(formula,method=method)
intensity_oracle = predict(fitted_oracle)
# # intensity of semiparametric model (logi)
# trend_linear = as.formula(paste("~",paste(c("cov_target","cov_nuisance"),collapse="+")))
# trend = "~cov_target+s(cov_nuisance)"
# ppmfit = ppm(Q = pp,trend = trend_linear ,covariates = data, method="logi")
# glmdata = ppmfit$internal$glmdata
# gamfit = gam(as.formula(paste('.logi.Y',trend)),data = glmdata, family = binomial(), subset = .logi.ok, weights = .logi.w)
# ## make the matrix consisting of cov_target and cov_nuisance in the uniform grid
# new_data = data.frame("cov_target" = c(cov_target[[1]]),"cov_nuisance" = c(cov_nuisance[[1]]))
#
# intensity_semi = fitted_values(gamfit,data = new_data,scale="link")$.fitted
#
# intensity_semi = matrix(intensity_semi,nrow = 100, ncol = 100)
# intensity of semiparametric model (mpl)
trend = "~cov_target+s(cov_nuisance)"
ppmfit =  ppm(Q = pp,trend = as.formula(trend) ,covariates = data, use.gam = TRUE, method="mpl")
intensity_semi = predict(ppmfit)
plot(intensity_para-lambda,col=my_colormap)
plot(intensity_semi-lambda,col=my_colormap)
plot(intensity_oracle-lambda,col=my_colormap)
set.seed(1)
clusters = "Poisson"
# generate the intensity for the point process
lambda = alpha*exp(theta*cov_target - eta*cov_nuisance^2)
formula = as.formula('pp~cov_target+I(cov_nuisance^2)')
# generate process
pp = simulate_process(lambda,clusters,var,scale)
# intensity of parametric misspecified model
fitted_para = ppm(pp~cov_target+cov_nuisance,method=method)
intensity_para = predict(fitted_para)
# intensity of oracle model
fitted_oracle = ppm(formula,method=method)
intensity_oracle = predict(fitted_oracle)
# # intensity of semiparametric model (logi)
# trend_linear = as.formula(paste("~",paste(c("cov_target","cov_nuisance"),collapse="+")))
# trend = "~cov_target+s(cov_nuisance)"
# ppmfit = ppm(Q = pp,trend = trend_linear ,covariates = data, method="logi")
# glmdata = ppmfit$internal$glmdata
# gamfit = gam(as.formula(paste('.logi.Y',trend)),data = glmdata, family = binomial(), subset = .logi.ok, weights = .logi.w)
# ## make the matrix consisting of cov_target and cov_nuisance in the uniform grid
# new_data = data.frame("cov_target" = c(cov_target[[1]]),"cov_nuisance" = c(cov_nuisance[[1]]))
#
# intensity_semi = fitted_values(gamfit,data = new_data,scale="link")$.fitted
#
# intensity_semi = matrix(intensity_semi,nrow = 100, ncol = 100)
# intensity of semiparametric model (mpl)
trend = "~cov_target+s(cov_nuisance)"
ppmfit =  ppm(Q = pp,trend = as.formula(trend) ,covariates = data, use.gam = TRUE, method="mpl")
intensity_semi = predict(ppmfit)
plot(intensity_para-lambda,col=my_colormap)
View(intensity_semi)
citation('ggplot2')
setwd("~/Desktop/IPP/JASA_ACC_Code")
citation('mgcv')
citation('stats')
R.version
packageVersion("spatstat")
packageVersion("mgcv")
packageVersion("gratia")
packageVersion("ggplot2")
packageVersion("stats")
installed.packages("stats")
citation("gmcv")
citation("mgcv")
##### plot logi nuisance estimation plot
#### system times: user: 6.405 seconds, system: 0.207, elapsed: 6.617
#### takes about 6.617 seconds to run
#### implemented on macbook pro 13.3 inch with M1 chip and 8G memory, macOS Ventura Versioin, 13.4.1(c)
library("dplyr")
library("gratia")
library(ggplot2)
library(spatstat)
# load data of capparis
load("bci.tree1.rdata")
cappfr = bci.tree1[bci.tree1$sp=="cappfr",]
cappfr = cappfr[!duplicated(cappfr[,c("gx","gy")]),]
pp_cap = ppp(cappfr$gx,cappfr$gy,window =owin(c(0,1000),c(0,500)))
ppmfit_bei =  ppm(bei~elev+s(grad), data = bei.extra,use.gam = TRUE, method="mpl")
ppmfit_cap =  ppm(pp_cap~elev+s(grad), covariates = bei.extra,use.gam = TRUE, method="mpl")
gamfit_bei = ppmfit_bei$internal$glmfit
gamfit_cap = ppmfit_cap$internal$glmfit
fitted_bei = fitted_values(gamfit_bei,data = gamfit_bei$model,exclude=c("elev"),scale="link")
fitted_bei$.fitted = fitted_bei$.fitted - gamfit_bei$coefficients["(Intercept)"]
fitted_cap = fitted_values(gamfit_cap,data=gamfit_cap$model,exclude=c("elev"),scale="link")
fitted_cap$.fitted = fitted_cap$.fitted - gamfit_cap$coefficients["(Intercept)"]
fitted_bind = fitted_cap %>% bind_rows(fitted_bei) %>% mutate(species=c(rep("Capparis ",dim(fitted_cap)[1]),rep("Beilschmiedia",dim(fitted_bei)[1])))
View(fitted_bind)
View(fitted_bei)
unique(fitted_bind$species)
# Plot the first line
plot(fitted_bei$grad, fitted_bei$.fitted, type = "l", col = "blue", lty = 1, lwd = 2,
xlab = "grad", ylab = "Value of the Estimated Nuisance Function", main = "")
# Add the second line
lines(fitted_cap$grad, fitted_cap$.fitted, col = "red", lty = 2, lwd = 2)
View(fitted_bei)
?mgcv::predict.gam
class(gamfit_bei)
predict(gamfit_bei,type="terms")
length(gamfit_bei$model$grad)
colnames(predict(gamfit_bei,type="terms"))
predict(gamfit_bei,type="terms")[,"s(grad)"]
plot(gamfit_bei$model$grad,predict(gamfit_bei,type="terms")[,"s(grad)"])
plot(density(gamfit_bei$model$grad))
seq
seq(0,0.3,100)
?seq
seq(from=0,to=1,by=0.01)
seq(from=0,to=0.3,by=0.3/100)
range(gamfit_bei$model$grad)
plot(gamfit_bei$model$grad,predict(gamfit_bei,type="terms")[,"s(grad)"],xlim=c(0,0.3))
# Plot the first line
plot(gamfit_bei$model$grad,predict(gamfit_bei,type="terms")[,"s(grad)"],xlim=c(0,0.3),type = "l", col = "blue", lty = 1, lwd = 2,
xlab = "grad", ylab = "Value of the Estimated Nuisance Function", main = "")
# Plot the first line
plot(gamfit_bei$model$grad,predict(gamfit_bei,type="terms")[,"s(grad)"],xlim=c(0,0.3),col = "blue", lty = 1, lwd = 2,
xlab = "grad", ylab = "Value of the Estimated Nuisance Function")
# Plot the first line
plot(gamfit_bei$model$grad,predict(gamfit_bei,type="terms")[,"s(grad)"],xlim=c(0,0.3),col = "blue", lty = 1, lwd = 1,
xlab = "grad", ylab = "Value of the Estimated Nuisance Function")
ggplot()+ geom_line(aes(x=gamfit_bei$model$grad,y=predict(gamfit_bei,type="terms")[,"s(grad)"],linetype="dased"))
ggplot()+ geom_line(aes(x=gamfit_bei$model$grad,y=predict(gamfit_bei,type="terms")[,"s(grad)"],linetype="dashed"))
ggplot()+ geom_line(aes(x=gamfit_bei$model$grad,y=predict(gamfit_bei,type="terms")[,"s(grad)"],linetype="dotted"))
ggplot()+ geom_line(aes(x=gamfit_bei$model$grad,y=predict(gamfit_bei,type="terms")[,"s(grad)"]),linetype="dotted")
ggplot()+ geom_line(aes(x=gamfit_bei$model$grad,y=predict(gamfit_bei,type="terms")[,"s(grad)"]),linetype="dashed")
head(predict(gamfit_bei,type="terms",terms = "grad"))
head(predict(gamfit_bei,type="terms",exclude = "elev"))
head(predict(gamfit_bei,newdata = data.frame(grad=seq(0,0.3,length.out=100)),type="terms",exclude = "elev"))
seq(0,0.3,length.out=100)
data.frame(grad=seq(0,0.3,length.out=100))
a = data.frame(grad=seq(0,0.3,length.out=100))
a
head(predict(gamfit_bei,newdata = a,type="terms",exclude = "elev"))
a = data.frame(grad=seq(0,0.3,length.out=100),elev=seq(0,0.3,length.out=100))
head(predict(gamfit_bei,newdata = a,type="terms",exclude = "elev"))
rep(NA,100)
a = data.frame(grad=seq(0,0.3,length.out=100),elev=rep(NA,100))
head(predict(gamfit_bei,newdata = a,type="terms",exclude = "elev"))
?expand.grid
newdata = data.frame(grad=seq(0,0.3,length.out=100),elev=seq(0,0.3,length.out=100))
fitted_bei = predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev")
fitted_bei$grad = seq(0,0.3,length.out=100)
fitted_bei = predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev")
seq(0,0.3,length.out=100)
fitted_bei$grad = seq(0,0.3,length.out=100)
View(fitted_bei)
fitted_bei = predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev")
class(fitted_bei)
fitted_bei = as.data.frame(predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev"))
fitted_bei$grad = c(seq(0,0.3,length.out=100))
fitted_bei = data.frame(grad=seq(0,0.3,length.out=100),pred=predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev"))
View(fitted_bei)
newdata = data.frame(grad=seq(0,0.3,length.out=100),elev=seq(0,0.3,length.out=100))
fitted_bei = data.frame(grad=seq(0,0.3,length.out=100),pred=predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev"))
fitted_cap = data.frame(grad=seq(0,0.3,length.out=100),pred=predict(gamfit_cap,newdata = newdata,type="terms",exclude = "elev"))
fitted_bind = fitted_cap %>% bind_rows(fitted_bei) %>% mutate(species=c(rep("Capparis ",dim(fitted_cap)[1]),rep("Beilschmiedia",dim(fitted_bei)[1])))
ggplot(data = fitted_bind,aes(x=grad,y=.fitted,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
fitted_bei = data.frame(grad=seq(0,0.3,length.out=100),.fitted=predict(gamfit_bei,newdata = newdata,type="terms",exclude = "elev"))
fitted_cap = data.frame(grad=seq(0,0.3,length.out=100),.fitted=predict(gamfit_cap,newdata = newdata,type="terms",exclude = "elev"))
fitted_bind = fitted_cap %>% bind_rows(fitted_bei) %>% mutate(species=c(rep("Capparis ",dim(fitted_cap)[1]),rep("Beilschmiedia",dim(fitted_bei)[1])))
ggplot(data = fitted_bind,aes(x=grad,y=.fitted,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
rlang::last_trace()
View(fitted_bind)
colnames(fitted_bind)
ggplot(data = fitted_bind,aes(x=grad,y=s.grad.,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
setwd("~/Desktop/IPP/JASA_ACC_Code")
source('Figure_2.R')
ggplot(data = fitted_bind,aes(x=grad,y=s.grad.,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
source('Figure_2.R')
source('Figure_2.R')
source('Figure_2.R')
png("Figure_2.png", width = 800, height = 600)
ggplot(data = fitted_bind,aes(x=grad,y=s.grad.,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
dev.off()
setwd("~/Desktop/IPP/JASA_ACC_Code")
source('Figure_2.R')
source('Figure_2.R')
source("~/Desktop/IPP/JASA_ACC_Code/Figure_2.R", echo=TRUE)
source("~/Desktop/IPP/JASA_ACC_Code/Figure_2.R", echo=TRUE)
source("~/Desktop/IPP/JASA_ACC_Code/Figure_2.R", echo=FALSE)
source("Figure_2.R", echo=FALSE)
source("Figure_2.R", echo=TRUE)
source("Figure_1.R", echo=TRUE)
ggplot(data = fitted_bind,aes(x=grad,y=s.grad.,group=species))+geom_line(aes(colour=species,linetype=species)) +labs(y="Value of the Estimated Nuisance Function")
version("ggplot")
version("ggplot2")
package_version("ggplot2")
package_version("ggplot")
packageVersion("ggplot2")
